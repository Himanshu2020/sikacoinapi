'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TurtleCoinWalletd = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * TurtleCoinWalletdRPC module - provides the TurtleCoinWalletd JSON-RPC wrapper for TurtleCoin's walletd daemon.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module TurtleCoinWalletd
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _rpcBuilders = require('./rpcBuilders');

var rpc = _interopRequireWildcard(_rpcBuilders);

var _popsicle = require('popsicle');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Wrapper for TurtleCoin walletd JSON-RPC interface */
var TurtleCoinWalletd = exports.TurtleCoinWalletd = function () {
  /**
   * Create an instance of TurtleCoinWalletd for interacting with TurtleCoin's walletd daemon
   * @param { string } host - the hostname of the walletd daemon (must include http://)
   * @param { int } port - the port number the walletd daemon is listening on
   * @param { string } rpcPassword - the password for walletd's JSON-RPC interface
   * @param { boolean } logging - switch to activate/deactivate logging
   */
  function TurtleCoinWalletd() {
    var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "http://127.0.0.1";
    var port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8070;
    var rpcPassword = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "test";
    var logging = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    _classCallCheck(this, TurtleCoinWalletd);

    this.host = host;
    this.port = port;
    this.rpcPassword = rpcPassword;
    this.id = 0;
    this.logging = logging;
  }

  /**
   * Private method. Sends the actual HTTP request to JSON-RPC daemon
   * @private
   */


  _createClass(TurtleCoinWalletd, [{
    key: '_sendXHR',
    value: function _sendXHR(payload, success, error) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var url = _this.host + ':' + _this.port + '/json_rpc',
            id = _this.id;
        if (_this.logging) {
          console.log('************');
          console.log('Sending HTTP request to walletd JSON-RPC interface at ' + url + '...');
          console.log('Request (id: ' + id + '):');
          console.log(payload);
          console.log('************');
        }

        (0, _popsicle.post)({
          url: url,
          body: payload
        }).then(function (res) {
          if (_this.logging) {
            console.log('************');
            console.log('Request (id: ' + id + ') to walletd HTTP JSON-RPC interface successful!');
            console.log(res.status);
            console.log(res.headers);
            console.log(res.body);
            console.log('************');
          }

          res.body = JSON.parse(res.body);
          success ? success(res) : resolve(res);
        }).catch(function (err) {
          if (_this.logging) {
            console.log('************');
            console.log('Error sending request (id: ' + id + ')');
            console.log(err);
            console.log('************');
          }

          error ? error(err) : resolve(err);
        });

        _this.id++;
      });
    }

    /**
     * Re-syncs the wallet
     * @param {string} [viewSecretKey] - Private view key for the wallet
     * If the viewSecretKey is not provided, reset() resets the wallet and re-syncs it. If the viewSecretKey argument is provided, reset() substitutes the existing wallet with a new one with the specified viewSecretKey and creates an address for it
     */

  }, {
    key: 'reset',
    value: function reset(viewSecretKey, sucess, error) {
      return this._sendXHR(rpc.reset(this.id, this.rpcPassword, viewSecretKey ? { viewSecretKey: viewSecretKey } : null), success, error);
    }

    /**
     * Saves the wallet
     */

  }, {
    key: 'save',
    value: function save(success, error) {
      return this._sendXHR(rpc.save(this.id, this.rpcPassword), success, error);
    }

    /**
     * Gets the wallet's private view key
     */

  }, {
    key: 'getViewKey',
    value: function getViewKey(success, error) {
      return this._sendXHR(rpc.getViewKey(this.id, this.rpcPassword), success, error);
    }

    /**
     * Gets the spend keys for an address
     * @param {string} address - Valid address that exists in the container
     */

  }, {
    key: 'getSpendKeys',
    value: function getSpendKeys(address, success, error) {
      return this._sendXHR(rpc.getSpendKeys(this.id, this.rpcPassword, { address: address }), success, error);
    }

    /**
     * Gets information about the current RPC wallet state:
     * blockCount, knownBlockCount, lastBlockHash, and peerCount
     */

  }, {
    key: 'getStatus',
    value: function getStatus(success, error) {
      return this._sendXHR(rpc.getStatus(this.id, this.rpcPassword), success, error);
    }

    /**
     * Gets an array of addresses in the wallet
     */

  }, {
    key: 'getAddresses',
    value: function getAddresses(success, error) {
      return this._sendXHR(rpc.getAddresses(this.id, this.rpcPassword), success, error);
    }

    /**
     * Creates an additional address in the wallet
     * @param {string} [secretSpendKey] - Private spend key. If specified, walletd creates a spend address.
     * @param {string} [publicSpendKey] - Public spend key. If specified, walletd creates a view address.
    * Note: If secretSpendKey or publicSpendKey parameters are specified, walletd creates a spend address with a generated spend key.
    * Note: Both parameters (secretSpendKey, viewSpendKey) cannot be present in a single request.
    */

  }, {
    key: 'createAddress',
    value: function createAddress(secretSpendKey, publicSpendKey, success, error) {
      return this._sendXHR(rpc.createAddress(this.id, this.rpcPassword, _extends({}, secretSpendKey && { secretSpendKey: secretSpendKey }, publicSpendKey && { publicSpendKey: publicSpendKey })), success, error);
    }

    /**
     *
     */

  }, {
    key: 'deleteAddress',
    value: function deleteAddress(address, success, error) {
      return this._sendXHR(rpc.deleteAddress(this.id, this.rpcPassword, { address: address }), success, error);
    }
  }, {
    key: 'getBalance',
    value: function getBalance(address, success, error) {
      return this._sendXHR(rpc.getBalance(this.id, this.rpcPassword, address ? { address: address } : null), success, error);
    }
  }, {
    key: 'getBlockHashes',
    value: function getBlockHashes(firstBlockIndex, blockCount, success, error) {
      return this._sendXHR(rpc.getBlockHashes(this.id, this.rpcPassword, {
        firstBlockIndex: firstBlockIndex,
        blockCount: blockCount
      }), success, error);
    }
  }, {
    key: 'getTransactionHashes',
    value: function getTransactionHashes(blockCount, firstBlockIndex, blockHash, addresses, paymentId, success, error) {
      return this._sendXHR(rpc.getTransactionHashes(this.id, this.rpcPassword, _extends({
        blockCount: blockCount
      }, firstBlockIndex && { firstBlockIndex: firstBlockIndex }, blockHash && { blockHash: blockHash }, addresses && { addresses: addresses }, paymentId && { paymentId: paymentId })), success, error);
    }
  }, {
    key: 'getTransactions',
    value: function getTransactions(blockCount, firstBlockIndex, blockHash, addresses, paymentId, success, error) {
      return this._sendXHR(rpc.getTransactions(this.id, this.rpcPassword, _extends({
        blockCount: blockCount
      }, firstBlockIndex && { firstBlockIndex: firstBlockIndex }, blockHash && { blockHash: blockHash }, addresses && { addresses: addresses }, paymentId && { paymentId: paymentId })), success, error);
    }
  }, {
    key: 'getUnconfirmedTransactionHashes',
    value: function getUnconfirmedTransactionHashes(addresses, success, error) {
      return this._sendXHR(rpc.getUnconfirmedTransactionHashes(this.id, this.rpcPassword, addresses ? { addresses: addresses } : null), success, error);
    }
  }, {
    key: 'getTransaction',
    value: function getTransaction(transactionHash, success, error) {
      return this._sendXHR(rpc.getTransaction(this.id, this.rpcPassword, { transactionHash: transactionHash }), success, error);
    }
  }, {
    key: 'sendTransaction',
    value: function sendTransaction(anonymity, transfers, fee, addresses, unlockTime, extra, paymentId, changeAddress, success, error) {
      return this._sendXHR(rpc.sendTransaction(this.id, this.rpcPassword, _extends({
        anonymity: anonymity,
        transfers: transfers,
        fee: fee
      }, addresses && { addresses: addresses }, unlockTime && { unlockTime: unlockTime }, extra && { extra: extra }, paymentId && { paymentId: paymentId }, changeAddress && { changeAddress: changeAddress })), success, error);
    }
  }, {
    key: 'createDelayedTransaction',
    value: function createDelayedTransaction(success, error) {
      return this._sendXHR(rpc.createDelayedTransaction(this.id, this.rpcPassword, _extends({
        anonymity: anonymity,
        transfers: transfers,
        fee: fee
      }, addresses && { addresses: addresses }, unlockTime && { unlockTime: unlockTime }, extra && { extra: extra }, paymentId && { paymentId: paymentId }, changeAddress && { changeAddress: changeAddress })), sucess, error);
    }
  }, {
    key: 'getDelayedTransactionHashes',
    value: function getDelayedTransactionHashes(success, error) {
      return this._sendXHR(rpc.getDelayedTransactionHashes(this.id, this.rpcPassword), success, error);
    }
  }, {
    key: 'deleteDelayedTransaction',
    value: function deleteDelayedTransaction(transactionHash, success, error) {
      return this._sendXHR(rpc.deleteDelayedTransaction(this.id, this.rpcPassword, { transactionHash: transactionHash }), success, error);
    }
  }, {
    key: 'sendDelayedTransaction',
    value: function sendDelayedTransaction(transactionHash, success, error) {
      return this._sendXHR(rpc.sendDelayedTransaction(this.id, this.rpcPassword, { transactionHash: transactionHash }), success, error);
    }
  }, {
    key: 'sendFusionTransaction',
    value: function sendFusionTransaction(threshold, anonymity, addresses, destinationAddress, success, error) {
      return this._sendXHR(rpc.sendFusionTransaction(this.id, this.rpcPassword, _extends({
        threshold: threshold,
        anonymity: anonymity
      }, addresses && { addresses: addresses }, destinationAddress && { destinationAddress: destinationAddress })), success, error);
    }
  }, {
    key: 'estimateFusion',
    value: function estimateFusion(threshold, addresses, success, error) {
      return this._sendXHR(rpc.estimateFusion(this.id, this.rpcPassword, _extends({
        threshold: threshold
      }, addresses && { addresses: addresses })), success, error);
    }
  }]);

  return TurtleCoinWalletd;
}();